<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR-UI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: Arial, sans-serif; }
        #webglCanvas { display: block; width: 100vw; height: 100vh; }
        #vrButton { /* ... styles ... */ }
    </style>
</head>
<body>
    <canvas id="webglCanvas"></canvas>
    <button id="vrButton">ENTER VR</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // VRButton.js (Unchanged)
        class VRButton { /* ... */ }
    </script>

    <script>
        // XR-UI Core Logic
        let camera, scene, renderer;
        let planeMesh;
        let canvasTexture, textureContext;

        const PANEL_ASPECT_RATIO = 16 / 9;
        const PLANE_BASE_WIDTH = 1.6; 
        const PLANE_HEIGHT = PLANE_BASE_WIDTH / PANEL_ASPECT_RATIO;
        const TEXTURE_BASE_HEIGHT = 540; 
        const TEXTURE_WIDTH = Math.round(TEXTURE_BASE_HEIGHT * PANEL_ASPECT_RATIO);
        const TEXTURE_HEIGHT = TEXTURE_BASE_HEIGHT;

        function init() { /* ... Scene, Camera, Renderer, WebXR setup ... */ 
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, PLANE_BASE_WIDTH * 0.9);
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webglCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            VRButton.createButton(renderer); // Assuming VRButton class is defined above or included

            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = TEXTURE_WIDTH;
            offscreenCanvas.height = TEXTURE_HEIGHT;
            textureContext = offscreenCanvas.getContext('2d');

            const initialHtml = 
                `<div id="root" style="background-color: #181818; color: #E0E0E0; padding: 10px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 20px; border: 1px solid #444;">
                    <div id="header" style="background-color: #282828; color: #00FF00; padding: 15px; margin-bottom: 10px; border: 2px dashed #00AA00; font-weight: bold; text-align: center;">
                        XR-UI Header
                    </div>
                    <p style="color: #CCCCCC; margin-bottom: 8px; font-size: 18px;">
                        This is the first paragraph demonstrating basic layout. 
                        Nested elements are now rendered!
                    </p>
                    <div id="content" style="background-color: #202020; padding: 10px; border-left: 3px solid #5555FF;">
                        <span style="color: #88CCFF; font-style: italic;">This is a span inside a content div.</span>
                        <p style="color: #FFDD88; margin-top: 5px; font-size: 16px;">Another paragraph, nested deeper.</p>
                    </div>
                    <div id="footer" style="margin-top: 15px; padding-top: 5px; border-top: 1px solid #333; font-size: 14px; text-align: right; color: #888;">
                        Footer Text
                    </div>
                </div>`;
            renderHTMLToTexture(initialHtml);

            canvasTexture = new THREE.CanvasTexture(offscreenCanvas);
            const planeGeometry = new THREE.PlaneGeometry(PLANE_BASE_WIDTH, PLANE_HEIGHT);
            const planeMaterial = new THREE.MeshBasicMaterial({ map: canvasTexture, side: THREE.DoubleSide, transparent: true });
            planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            scene.add(planeMesh);

            window.addEventListener('resize', onWindowResize, false);
            renderer.setAnimationLoop(animate);

            // No dynamic update for now, to focus on initial render
        }

        function parseStyleString(styleStr) { /* ... unchanged ... */ 
            const styles = {}; if (!styleStr) return styles;
            styleStr.split(';').forEach(declaration => {
                if (declaration.trim() === '') return; const [property, value] = declaration.split(':').map(s => s.trim());
                if (property && value) { const camelCaseProperty = property.replace(/-([a-z])/g, g => g[1].toUpperCase()); styles[camelCaseProperty] = value; }
            }); return styles;
        }
        
        function parseHTMLString(htmlString) { /* ... unchanged ... */ 
            const result = []; const stack = [{ children: result }]; let match;
            const tagRegex = /<\/?([a-z][a-z0-9]*)\s*([^>]*?)?>|([^<]+)/gi;
            while ((match = tagRegex.exec(htmlString))) {
                const [fullMatch, tagName, attributesStr, textContent] = match; const parent = stack[stack.length - 1];
                if (tagName) {
                    if (fullMatch.startsWith('</')) { if (stack.length > 1 && parent.tagName === tagName) { stack.pop(); } else { console.warn(`Mismatched closing tag: expected </${parent.tagName}>, got ${fullMatch}`); }
                    } else { const attributes = {}; if (attributesStr) { const attrRegex = /([a-zA-Z0-9_-]+)(?:\s*=\s*(?:"([^"]*)"|'([^']*)'|([^>\s]+)))?/g; let attrMatch; while ((attrMatch = attrRegex.exec(attributesStr))) { attributes[attrMatch[1]] = attrMatch[2] || attrMatch[3] || attrMatch[4] || ''; } } const elementNode = { tagName, attributes, children: [] }; parent.children.push(elementNode); stack.push(elementNode); }
                } else if (textContent && textContent.trim() !== '') { parent.children.push(textContent.trim()); }
            } if (stack.length > 1) { console.warn("Unclosed tags:", stack.slice(1).map(s => s.tagName)); } return result;
        }

        /**
         * Calculates an estimated height for an element based on its text content and styles.
         * This is a very basic estimation.
         */
        function estimateElementHeight(node, styles, availableWidth, ctx) {
            const s = styles; // Resolved styles passed in
            let textContent = '';
            if (node.children) {
                const textChild = node.children.find(child => typeof child === 'string');
                if (textChild) textContent = textChild;
            }

            const lineHeight = s.fontSize * 1.2;
            let numLines = 1;

            if (textContent) {
                ctx.font = `${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`; // Set font for measurement
                const words = textContent.split(' ');
                let currentLine = '';
                numLines = 0;
                for (let n = 0; n < words.length; n++) {
                    let testLine = currentLine + words[n] + ' ';
                    let metrics = ctx.measureText(testLine.trim());
                    if (metrics.width > availableWidth && currentLine.length > 0) {
                        numLines++;
                        currentLine = words[n] + ' ';
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine.trim().length > 0) numLines++; // Last line
                if (numLines === 0 && textContent.length > 0) numLines = 1; // At least one line if there's text
            }
            
            // Total height includes padding, border, and text lines.
            // Does not account for children's height yet in this estimation.
            return s.paddingTop + s.paddingBottom + (s.borderWidth * 2) + (numLines * lineHeight);
        }


        /**
         * Renders a single element node and its children recursively.
         * @param {object} node - The element node to render.
         * @param {CanvasRenderingContext2D} ctx - The 2D rendering context.
         * @param {number} x - The x-coordinate for this element's bounding box.
         * @param {number} y - The y-coordinate for this element's bounding box.
         * @param {number} width - The available width for this element.
         * @param {number} height - The available height for this element (can be estimated or fixed).
         * @returns {number} The actual height used by this element and its children.
         */
        function renderElementAndChildren(node, ctx, x, y, availableWidth) {
            const styles = parseStyleString(node.attributes.style);
            const s = { // Resolved styles
                backgroundColor: styles.backgroundColor || 'transparent', color: styles.color || '#000000',
                paddingTop: parseInt(styles.paddingTop || styles.padding || '0'), paddingRight: parseInt(styles.paddingRight || styles.padding || '0'),
                paddingBottom: parseInt(styles.paddingBottom || styles.padding || '0'), paddingLeft: parseInt(styles.paddingLeft || styles.padding || '0'),
                marginTop: parseInt(styles.marginTop || '0'), marginBottom: parseInt(styles.marginBottom || '0'), // Basic margin
                fontSize: parseInt(styles.fontSize || '16'), fontFamily: styles.fontFamily || 'Arial',
                fontWeight: styles.fontWeight || 'normal', borderWidth: 0, borderStyle: 'solid',
                borderColor: 'transparent', textAlign: styles.textAlign || 'left',
                display: styles.display || 'block' // Basic display property
            };
            if (styles.border) { const bp = styles.border.match(/(\d+)\s*px\s+(\w+)\s+(.*)/i); if (bp) { s.borderWidth = parseInt(bp[1]); s.borderStyle = bp[2].toLowerCase(); s.borderColor = bp[3];}}

            const elementOuterY = y + s.marginTop;

            // --- Draw current element's background and border ---
            const elementRectX = x + (s.borderWidth / 2);
            const elementRectY = elementOuterY + (s.borderWidth / 2);
            const elementRectWidth = availableWidth - s.borderWidth;
            
            // Estimate height for text content of *this* element
            let textContent = node.children.find(child => typeof child === 'string') || '';
            let textLines = [];
            const lineHeight = s.fontSize * 1.2;
            if (textContent) {
                ctx.font = `${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`;
                const words = textContent.split(' '); let currentLine = '';
                for (let n = 0; n < words.length; n++) {
                    let testLine = currentLine + words[n] + ' ';
                    if (ctx.measureText(testLine.trim()).width > (elementRectWidth - s.paddingLeft - s.paddingRight) && currentLine.length > 0) {
                        textLines.push(currentLine.trim()); currentLine = words[n] + ' ';
                    } else { currentLine = testLine; }
                }
                textLines.push(currentLine.trim());
            }
            const textBlockHeight = textLines.length > 0 ? (textLines.length * lineHeight - (lineHeight - s.fontSize)) : 0;
            
            let currentElementInnerHeight = textBlockHeight; // Start with text height

            // --- Recursively render children and sum their heights ---
            const childrenX = elementRectX + s.paddingLeft;
            let childrenY = elementRectY + s.paddingTop + textBlockHeight; // Children start after this element's text
            const childrenWidth = elementRectWidth - s.paddingLeft - s.paddingRight;
            
            let maxChildHeight = 0;
            node.children.forEach(childNode => {
                if (typeof childNode !== 'string') { // If it's an element node
                    const childHeight = renderElementAndChildren(childNode, ctx, childrenX, childrenY, childrenWidth);
                    childrenY += childHeight; // Stack children vertically
                    maxChildHeight += childHeight;
                }
            });
            currentElementInnerHeight += maxChildHeight; // Add children's height to inner height

            const currentElementTotalHeight = s.paddingTop + currentElementInnerHeight + s.paddingBottom + s.borderWidth * 2;
            const elementRectHeight = currentElementTotalHeight - s.borderWidth;


            if (s.backgroundColor !== 'transparent') {
                ctx.fillStyle = s.backgroundColor;
                ctx.fillRect(elementRectX, elementRectY, elementRectWidth, elementRectHeight);
            }
            if (s.borderWidth > 0) {
                ctx.strokeStyle = s.borderColor; ctx.lineWidth = s.borderWidth;
                if (s.borderStyle === 'dashed') ctx.setLineDash([s.borderWidth * 2, s.borderWidth * 1.5]);
                else if (s.borderStyle === 'dotted') ctx.setLineDash([s.borderWidth, s.borderWidth]);
                else ctx.setLineDash([]);
                ctx.strokeRect(elementRectX, elementRectY, elementRectWidth, elementRectHeight);
                ctx.setLineDash([]);
            }

            // --- Draw text content of *this* element ---
            if (textLines.length > 0) {
                ctx.fillStyle = s.color; ctx.font = `${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`;
                ctx.textBaseline = 'top'; ctx.textAlign = s.textAlign;
                let textDrawY = elementRectY + s.paddingTop;
                for (let i = 0; i < textLines.length; i++) {
                    let drawX = elementRectX + s.paddingLeft;
                    if (s.textAlign === 'center') drawX = elementRectX + s.paddingLeft + (elementRectWidth - s.paddingLeft - s.paddingRight) / 2;
                    else if (s.textAlign === 'right') drawX = elementRectX + s.paddingLeft + (elementRectWidth - s.paddingLeft - s.paddingRight);
                    ctx.fillText(textLines[i], drawX, textDrawY);
                    textDrawY += lineHeight;
                }
            }
            return currentElementTotalHeight + s.marginTop + s.marginBottom; // Return full occupied height including margins
        }

        /**
         * Renders a tree of nodes onto the canvas.
         */
        function renderNodeTree(nodes, ctx, x, y, availableWidth, availableHeight) {
            let currentY = y;
            nodes.forEach(node => {
                if (typeof node === 'string') {
                    // For now, top-level text nodes in a children array are ignored by renderElementAndChildren directly.
                    // A proper layout engine would handle inline flow. Here we assume block stacking.
                    // We could draw it simply here if needed, but it's better handled inside elements.
                    console.warn("Standalone text node in tree, not rendered by current block layout:", node);
                } else { // It's an element node
                    const elementHeight = renderElementAndChildren(node, ctx, x, currentY, availableWidth);
                    currentY += elementHeight; // Stack elements vertically
                }
            });
        }

        function renderHTMLToTexture(htmlString) {
            textureContext.clearRect(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT); // Clear canvas once
            const nodeTree = parseHTMLString(htmlString);

            if (nodeTree.length > 0) {
                renderNodeTree(nodeTree, textureContext, 0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);
            } else {
                // Fallback if parsing fails
                textureContext.fillStyle = "red"; textureContext.font = "20px Arial";
                textureContext.fillText("Error: No parsable content.", 10, 30);
            }

            if (canvasTexture) canvasTexture.needsUpdate = true;
        }

        function onWindowResize() { /* ... unchanged ... */ }
        function animate() { /* ... unchanged ... */ }
        init();
    </script>
</body>
</html>
