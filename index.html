<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XR-UI</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: Arial, sans-serif; }
        #webglCanvas { display: block; width: 100vw; height: 100vh; }
        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border: 1px solid #fff;
            background: rgba(0,0,0,0.5);
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            z-index: 1000;
            opacity: 0.9;
        }
        #vrButton:hover { background: rgba(255,255,255,0.2); opacity: 1.0; }
    </style>
</head>
<body>
    <canvas id="webglCanvas"></canvas>
    <button id="vrButton">ENTER VR</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        /**
         * VRButton: Manages the WebXR session button.
         * Adapted from Three.js examples.
         */
        class VRButton {
            static createButton( renderer, options ) {
                if ( options && options.referenceSpaceType ) { renderer.xr.setReferenceSpaceType( options.referenceSpaceType ); }
                const button = document.getElementById('vrButton'); 
                let currentSession = null;

                function onSessionStarted( session ) { 
                    session.addEventListener( 'end', onSessionEnded ); 
                    renderer.xr.setSession( session ); 
                    button.textContent = 'EXIT VR'; 
                    currentSession = session; 
                }
                function onSessionEnded() { 
                    if (currentSession) { currentSession.removeEventListener( 'end', onSessionEnded ); } 
                    button.textContent = 'ENTER VR'; 
                    currentSession = null; 
                }
                
                button.style.display = 'none'; // Hide until WebXR support is determined

                function showEnterVR( _button ) { 
                    _button.style.display = ''; 
                    _button.style.cursor = 'pointer'; 
                    _button.onclick = function () { 
                        if ( currentSession === null ) { 
                            const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking', 'layers' ] }; 
                            navigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted ); 
                        } else { currentSession.end(); } 
                    }; 
                }
                function disableButton( _button ) { 
                    _button.style.display = ''; 
                    _button.style.cursor = 'auto'; 
                    _button.onclick = null; 
                }
                function showWebXRNotFound( _button ) { 
                    disableButton( _button ); 
                    _button.textContent = 'VR NOT SUPPORTED'; 
                }
                
                if ( 'xr' in navigator ) { 
                    navigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) { 
                        supported ? showEnterVR( button ) : showWebXRNotFound( button ); 
                        if ( options && options.onSessionSupported ) options.onSessionSupported( supported ); 
                    }).catch( function () { 
                        showWebXRNotFound( button ); 
                        if ( options && options.onSessionSupported ) options.onSessionSupported( false ); 
                    }); 
                    return button;
                } else { 
                    const message = document.createElement( 'a' ); 
                    message.innerHTML = window.isSecureContext === false ? 'WEBXR NEEDS HTTPS' : 'WEBXR NOT AVAILABLE'; 
                    if (window.isSecureContext === false) message.href = document.location.href.replace( /^http:/, 'https:' ); 
                    else message.href = 'https://immersiveweb.dev/'; 
                    message.style.textDecoration = 'none'; 
                    message.style.color = '#fff'; 
                    message.style.display = 'block'; 
                    message.style.textAlign = 'center'; 
                    button.parentNode.replaceChild(message, button); 
                    return message; 
                }
            }
        }
    </script>

    <script>
        // XR-UI Core Logic
        let camera, scene, renderer;
        let planeMesh; // The 3D plane that acts as our UI surface
        let canvasTexture, textureContext; // For rendering HTML content to a texture

        // Configuration for the UI panel's appearance in 3D space and its texture resolution
        const PANEL_ASPECT_RATIO = 16 / 9;
        const PLANE_BASE_WIDTH = 1.6; // Width of the 3D plane in world units
        const PLANE_HEIGHT = PLANE_BASE_WIDTH / PANEL_ASPECT_RATIO;
        const TEXTURE_BASE_HEIGHT = 540; // Pixel height of the offscreen canvas for the texture
        const TEXTURE_WIDTH = Math.round(TEXTURE_BASE_HEIGHT * PANEL_ASPECT_RATIO);
        const TEXTURE_HEIGHT = TEXTURE_BASE_HEIGHT;

        /**
         * Initializes the Three.js scene, WebXR, and the UI panel.
         */
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, PLANE_BASE_WIDTH * 0.9); // Position camera to view the plane

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webglCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            VRButton.createButton(renderer); // Setup WebXR session button

            // Create an offscreen canvas to render HTML content onto
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = TEXTURE_WIDTH;
            offscreenCanvas.height = TEXTURE_HEIGHT;
            textureContext = offscreenCanvas.getContext('2d');

            // Initial content for the UI panel
            const initialHtml = `<div style="background-color: #333; color: #0F0; padding: 25px; font-size: 38px; font-family: 'Lucida Console', Monaco, monospace; border: 6px dashed #0A0; text-align: left; font-weight: bold;">XR-UI Initializing...</div>`;
            renderHTMLToTexture(initialHtml);

            canvasTexture = new THREE.CanvasTexture(offscreenCanvas);
            // For smoother text rendering on the 3D plane:
            // canvasTexture.minFilter = THREE.LinearFilter;
            // canvasTexture.magFilter = THREE.LinearFilter;

            const planeGeometry = new THREE.PlaneGeometry(PLANE_BASE_WIDTH, PLANE_HEIGHT);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                map: canvasTexture, 
                side: THREE.DoubleSide, 
                transparent: true // Enable transparency for RGBA textures
            });
            planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            scene.add(planeMesh);

            window.addEventListener('resize', onWindowResize, false);
            renderer.setAnimationLoop(animate); // Start the render loop

            // Example of dynamically updating the panel content
            setTimeout(() => {
                const updatedHtml = `<p style="background-color: #502020; color: #FFD; padding: 15px 30px; font-size: 28px; font-family: Georgia, serif; border: 4px solid #A55; text-align: right; font-weight: normal;">Content has been updated dynamically. This demonstrates the ability to refresh the UI panel with new HTML. More text for wrapping test.</p>`;
                renderHTMLToTexture(updatedHtml);
            }, 5000);
        }

        /**
         * Parses a CSS style string (e.g., "color: red; font-size: 10px")
         * into a JavaScript object with camelCased keys.
         */
        function parseStyleString(styleStr) {
            const styles = {};
            if (!styleStr) return styles;

            styleStr.split(';').forEach(declaration => {
                if (declaration.trim() === '') return;
                const [property, value] = declaration.split(':').map(s => s.trim());
                if (property && value) {
                    const camelCaseProperty = property.replace(/-([a-z])/g, g => g[1].toUpperCase());
                    styles[camelCaseProperty] = value;
                }
            });
            return styles;
        }

        /**
         * Renders a representation of a single HTML-like element onto the provided canvas context.
         * This function currently handles basic styling for one element.
         * @param {string} tagName - The tag name of the element (e.g., 'div', 'p').
         * @param {object} styles - Parsed CSS styles for the element.
         * @param {string} textContent - The inner text content of the element.
         * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the offscreen canvas.
         * @param {number} canvasWidth - The width of the offscreen canvas.
         * @param {number} canvasHeight - The height of the offscreen canvas.
         */
        function renderElementOnCanvas(tagName, styles, textContent, ctx, canvasWidth, canvasHeight) {
            const s = { // Resolved styles with defaults
                backgroundColor: styles.backgroundColor || 'transparent',
                color: styles.color || '#000000',
                paddingTop: parseInt(styles.paddingTop || styles.padding || '10'),
                paddingRight: parseInt(styles.paddingRight || styles.padding || '10'),
                paddingBottom: parseInt(styles.paddingBottom || styles.padding || '10'),
                paddingLeft: parseInt(styles.paddingLeft || styles.padding || '10'),
                fontSize: parseInt(styles.fontSize || '24'),
                fontFamily: styles.fontFamily || 'Arial',
                fontWeight: styles.fontWeight || 'normal',
                borderWidth: 0,
                borderStyle: 'solid',
                borderColor: 'transparent',
                textAlign: styles.textAlign || 'left'
            };

            if (styles.border) {
                const borderParts = styles.border.match(/(\d+)\s*px\s+(\w+)\s+(.*)/i);
                if (borderParts && borderParts.length === 4) {
                    s.borderWidth = parseInt(borderParts[1]);
                    s.borderStyle = borderParts[2].toLowerCase();
                    s.borderColor = borderParts[3];
                }
            }
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight); // Clear entire canvas

            const boxX = s.borderWidth / 2;
            const boxY = s.borderWidth / 2;
            const boxWidth = canvasWidth - s.borderWidth;
            const boxHeight = canvasHeight - s.borderWidth;

            ctx.fillStyle = s.backgroundColor;
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

            if (s.borderWidth > 0) {
                ctx.strokeStyle = s.borderColor;
                ctx.lineWidth = s.borderWidth;
                if (s.borderStyle === 'dashed') ctx.setLineDash([s.borderWidth * 2, s.borderWidth * 1.5]);
                else if (s.borderStyle === 'dotted') ctx.setLineDash([s.borderWidth, s.borderWidth]);
                else ctx.setLineDash([]); // Solid
                ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
                ctx.setLineDash([]); // Reset line dash
            }
            
            const contentX = boxX + s.paddingLeft;
            const contentY = boxY + s.paddingTop;
            const contentWidth = boxWidth - s.paddingLeft - s.paddingRight;
            const contentHeight = boxHeight - s.paddingTop - s.paddingBottom;

            ctx.fillStyle = s.color;
            ctx.font = `${s.fontWeight} ${s.fontSize}px ${s.fontFamily}`;
            ctx.textBaseline = 'top'; // Align text to the top for easier multi-line layout
            ctx.textAlign = s.textAlign;

            const words = textContent.split(' ');
            let line = '';
            const lines = [];
            const lineHeight = s.fontSize * 1.2; 

            for (let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                let metrics = ctx.measureText(testLine.trim());
                if (metrics.width > contentWidth && line.length > 0) {
                    lines.push(line.trim());
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line.trim());

            let currentY = contentY; // Start drawing text from the top of the content area
            // Basic vertical centering attempt (can be improved)
            // const totalTextHeight = lines.length * lineHeight - (lineHeight - s.fontSize); // More accurate height
            // currentY = contentY + Math.max(0, (contentHeight - totalTextHeight) / 2);


            for (let i = 0; i < lines.length; i++) {
                if (currentY + s.fontSize > contentY + contentHeight) break; // Prevent overflow

                let drawX = contentX;
                if (s.textAlign === 'center') drawX = contentX + contentWidth / 2;
                else if (s.textAlign === 'right') drawX = contentX + contentWidth;
                
                ctx.fillText(lines[i], drawX, currentY);
                currentY += lineHeight;
            }
        }

        /**
         * Main function to render an HTML string to the UI panel's texture.
         * Currently handles a single top-level HTML element.
         */
        function renderHTMLToTexture(htmlString) {
            // Rudimentary extraction for a SINGLE top-level element.
            // This will be replaced by a proper HTML tree parser.
            let tagName = 'div'; 
            let styleStr = '';
            let textContent = 'Error: Could not parse content.';

            const tagMatch = htmlString.match(/^<(\w+)/);
            if (tagMatch) tagName = tagMatch[1];

            const styleMatch = htmlString.match(/style="([^"]*)"/);
            if (styleMatch) styleStr = styleMatch[1];
            
            // More robust content extraction that handles attributes before the ">"
            const contentMatch = htmlString.match(/>([^<]*)<\/\w+>$/);
            if (contentMatch && contentMatch[1]) {
                textContent = contentMatch[1].trim();
            } else {
                 // Fallback for simple cases or if the above fails due to complex attributes
                const simpleContentMatch = htmlString.match(/>([^<]+)</);
                if (simpleContentMatch) textContent = simpleContentMatch[1].trim();
            }
            
            const styles = parseStyleString(styleStr);
            
            renderElementOnCanvas(tagName, styles, textContent, textureContext, TEXTURE_WIDTH, TEXTURE_HEIGHT);

            if (canvasTexture) {
                canvasTexture.needsUpdate = true; // Signal Three.js to update the texture
            }
        }

        /**
         * Handles window resize events to update camera and renderer.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * The main animation loop.
         */
        function animate() {
            // Example: planeMesh.rotation.y += 0.001; // For visual debugging
            renderer.render(scene, camera);
        }

        // Initialize the application
        init();
    </script>
</body>
</html>
